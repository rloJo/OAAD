## 문제 조건
> <a href = "https://www.acmicpc.net/problem/1916"> 문제 링크 </a>  
> 시간제한 : 0.5초  
> 메모리 제한 : 128MB  
> 정답 비율 : 32.616%

### 풀이 과정
---
1. 모든 정점을 입력 받는다.
2. 입력을 받을 때 edges[출발점].push_back({cost,도착점}) 식으로 입력을 받는다.
3. 다른 모든 정점으로의 최단 경로를 구하는 문제이므로 다익스트라 알고리즘을 이용했다.
4. 우선 시작점 기준 다른 노드에 대한 비용을 저장하는 배열을 무한대로 저장
5. 시작점->시작점으로 가는 비용 배열을 0으로 수정하고 우선순위큐에 {cost[시작점],시작점} 삽입
6. 이때 조심할 점은 우선순위큐는 비용이 작은게 위로 올라와야한다.
7. **만약에 현재 pop한 값이 거리가 다를 경우 넘어간다 continue cost[cur.second]!=cost.first**
8. 그 후 시작점에서 뻗는 간선을 계산한다. 이때 cost[다음점]이 cost[cur] + 시작점->다음점 비용 보다 클경우만 다음 단계진행
9. cost[다음점]을 cost[cur] +  시작점->다음점 비용 으로 삽입한다.
10. 우선순위 큐에 cost[next],next 삽입

###  트러블 슈팅
---
1. 시간 초과 발생하는 일이 벌어졌다.

7번 과정을 넣어서 해
